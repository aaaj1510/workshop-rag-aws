# üöÄ PASOS DEL WORKSHOP RAG - GU√çA ESTUDIANTES

## üìã **PREREQUISITOS**
- Cuenta AWS con acceso a Bedrock (opcional)
- Regi√≥n: **us-east-1** (recomendado)
- Navegador web moderno
- Editor de c√≥digo (opcional)

---

## üéØ **PASO 1: CREAR INFRAESTRUCTURA BASE**

### **1.1 Desplegar CloudFormation**
1. **AWS Console** ‚Üí Buscar "CloudFormation" ‚Üí **us-east-1**
2. **Create stack** ‚Üí **With new resources (standard)**
3. **Template source**: Upload a template file
4. **Choose file**: Seleccionar `infrastructure-base.yaml`
5. **Next**
6. **Stack name**: `rag-workshop-base-{tu-nombre}`
7. **StudentName**: `{tu-nombre}` (ej: juan-perez)
8. **Next** ‚Üí **Next** ‚Üí **Submit**
9. **Esperar** hasta ver **CREATE_COMPLETE** (5-10 minutos)

**üìã ¬øQu√© se crea autom√°ticamente?**
- ‚úÖ **S3 Bucket** para almacenar documentos
- ‚úÖ **DynamoDB Table** para vectores y chunks
- ‚úÖ **IAM Role** con permisos para Lambda
- ‚úÖ **2 Lambda Functions** con c√≥digo placeholder
- ‚úÖ **CloudWatch Log Groups** para debugging
- ‚úÖ **Variables de entorno** configuradas autom√°ticamente

### **1.2 Explorar S3 Bucket Creado**
1. **AWS Console** ‚Üí Buscar "S3"
2. **Buscar bucket**: `rag-workshop-{tu-nombre}-docs-{account-id}`
3. **Click en el bucket** ‚Üí Explorar:
   - **Properties** ‚Üí Ver configuraci√≥n
   - **Permissions** ‚Üí Ver pol√≠ticas de seguridad
   - **Management** ‚Üí Ver versionado habilitado
4. **Anotar el nombre exacto** del bucket

### **1.3 Explorar DynamoDB Table**
1. **AWS Console** ‚Üí Buscar "DynamoDB"
2. **Tables** ‚Üí Buscar `rag-workshop-{tu-nombre}-vectors`
3. **Click en la tabla** ‚Üí Explorar:
   - **Overview** ‚Üí Ver configuraci√≥n Pay-per-request
   - **Items** ‚Üí Ver que est√° vac√≠a (por ahora)
   - **Overview** ‚Üí Ver **Primary key**: 
     - **Partition key**: `document_id` (String)
     - **Sort key**: `chunk_id` (String)
4. **Anotar el nombre exacto** de la tabla

### **1.4 Explorar IAM Role**
1. **AWS Console** ‚Üí Buscar "IAM"
2. **Roles** ‚Üí Buscar `rag-workshop-{tu-nombre}-lambda-role`
3. **Click en el role** ‚Üí Explorar:
   - **Trust relationships** ‚Üí Ver que Lambda puede asumir este rol
   - **Permissions** ‚Üí Ver pol√≠ticas:
     - AWSLambdaBasicExecutionRole (CloudWatch logs)
     - WorkshopLambdaPermissions (S3, DynamoDB, Bedrock)
4. **Click en WorkshopLambdaPermissions** ‚Üí **Show policy** ‚Üí Ver JSON:
   ```json
   {
     "Effect": "Allow",
     "Action": ["bedrock:InvokeModel", "bedrock:ListFoundationModels"],
     "Resource": "*"
   }
   ```

---

## üîß **PASO 2: ACTUALIZAR FUNCIONES LAMBDA**

### **2.1 Verificar Lambda Functions Creadas**
1. **AWS Console** ‚Üí Buscar "Lambda"
2. **Functions** ‚Üí Verificar que existen:
   - `rag-workshop-{tu-nombre}-document-processor`
   - `rag-workshop-{tu-nombre}-query-handler`
3. **Si no existen**, fueron creadas por CloudFormation con c√≥digo placeholder

### **2.2 Actualizar Document Processor**
1. **Click** en `rag-workshop-{tu-nombre}-document-processor`
2. **Explorar configuraci√≥n**:
   - **Runtime**: Python 3.11
   - **Handler**: lambda_function.lambda_handler
   - **Timeout**: 5 minutos (300 segundos)
   - **Memory**: 512 MB

3. **Configuration** ‚Üí **Environment variables**:
   - `VECTOR_TABLE`: `rag-workshop-{tu-nombre}-vectors` (para conectar con DynamoDB)
   - `DOCUMENTS_BUCKET`: `rag-workshop-{tu-nombre}-docs-{account-id}` (para leer archivos de S3)
   - **Save**
   
   **üí° ¬øPor qu√© estas variables?**
   - Lambda necesita saber qu√© tabla DynamoDB usar para guardar vectores
   - Lambda necesita saber de qu√© bucket S3 descargar documentos
   - CloudFormation ya configur√≥ los nombres √∫nicos autom√°ticamente

4. **Code** tab ‚Üí **Reemplazar todo el c√≥digo** con:
   - Abrir archivo `lambda/document_processor/lambda_function.py`
   - **Copiar todo el contenido**
   - **Pegar** en el editor de Lambda
   - **Deploy**
   
   **üö® PROBLEMA COM√öN: Si aparece "No module named 'lambda_function'"**
   - El archivo se cre√≥ como `index.py` en lugar de `lambda_function.py`
   - **Soluci√≥n**: Click derecho en el editor ‚Üí **New File** ‚Üí Nombrar `lambda_function.py`
   - **Pegar el c√≥digo** en el nuevo archivo
   - **Deploy** nuevamente

5. **Explorar el c√≥digo** - L√≠neas importantes:
   - **L√≠nea 10**: `bedrock_client = boto3.client('bedrock-runtime', region_name='us-east-1')`
   - **L√≠nea 13**: `VECTOR_TABLE = os.environ['VECTOR_TABLE']`
   - **L√≠nea 14**: `DOCUMENTS_BUCKET = os.environ['DOCUMENTS_BUCKET']`
   - **L√≠nea 93**: Funci√≥n `generate_embedding()` que llama a Bedrock
   - **L√≠nea 99**: `modelId="amazon.titan-embed-text-v1"` (Modelo de embeddings)
   - **L√≠nea 119**: Conversi√≥n a Decimal para DynamoDB

### **2.3 Actualizar Query Handler**
1. **Click** en `rag-workshop-{tu-nombre}-query-handler`
2. **Configuration** ‚Üí **Environment variables**:
   - `VECTOR_TABLE`: `rag-workshop-{tu-nombre}-vectors` (para buscar vectores en DynamoDB)
   - **Save**
   
   **üí° ¬øPor qu√© esta variable?**
   - Lambda necesita saber en qu√© tabla DynamoDB buscar los vectores guardados
   - Usa la misma tabla que el document processor para consistencia

3. **Code** tab ‚Üí **Reemplazar todo el c√≥digo** con:
   - Abrir archivo `lambda/query_handler/lambda_function.py`
   - **Copiar todo el contenido**
   - **Pegar** en el editor de Lambda
   - **Deploy**
   
   **üö® PROBLEMA COM√öN: Si aparece "No module named 'lambda_function'"**
   - El archivo se cre√≥ como `index.py` en lugar de `lambda_function.py`
   - **Soluci√≥n**: Click derecho en el editor ‚Üí **New File** ‚Üí Nombrar `lambda_function.py`
   - **Pegar el c√≥digo** en el nuevo archivo
   - **Deploy** nuevamente

4. **Explorar el c√≥digo** - L√≠neas importantes:
   - **L√≠nea 10**: `bedrock_client = boto3.client('bedrock-runtime', region_name='us-east-1')`
   - **L√≠nea 13**: `VECTOR_TABLE = os.environ['VECTOR_TABLE']`
   - **L√≠nea 58**: Funci√≥n `generate_embedding()` para la query
   - **L√≠nea 64**: `modelId="amazon.titan-embed-text-v1"` (Mismo modelo)
   - **L√≠nea 77**: Funci√≥n `cosine_similarity()` sin numpy
   - **L√≠nea 129**: Funci√≥n `generate_rag_response()` que llama a Claude
   - **L√≠nea 154**: `modelId="anthropic.claude-3-sonnet-20240229-v1:0"` (Modelo de texto)

### **2.4 Verificar Permisos de Bedrock**
1. **Configuration** ‚Üí **Permissions** ‚Üí **Execution role**
2. **Click** en el role name
3. **Permissions** ‚Üí **WorkshopLambdaPermissions** ‚Üí **Show policy**
4. **Verificar l√≠neas de Bedrock**:
   ```json
   {
     "Effect": "Allow",
     "Action": [
       "bedrock:InvokeModel",
       "bedrock:ListFoundationModels"
     ],
     "Resource": "*"
   }
   ```

---

## üß™ **PASO 3: CONFIGURAR Y PROBAR BEDROCK**

### **3.1 Habilitar Modelos en Bedrock**
1. **AWS Console** ‚Üí Buscar "Bedrock"
2. **Model access** (men√∫ izquierdo)
3. **Manage model access** (bot√≥n naranja)
4. **Buscar y habilitar**:
   - ‚úÖ **Amazon Titan Text Embeddings v1**
   - ‚úÖ **Anthropic Claude 3 Sonnet**
5. **Next** ‚Üí **Submit**
6. **Esperar** que el status cambie a "Access granted" (puede tomar minutos)

### **3.2 Subir Documento de Prueba a S3**
1. **S3 Console** ‚Üí Tu bucket `rag-workshop-{tu-nombre}-docs-{account-id}`
2. **Upload** ‚Üí **Add files**
3. **Seleccionar** `test-documents/company_policy.txt`
4. **Upload**
5. **Verificar** que el archivo aparece en el bucket

### **3.3 Probar Document Processor**
1. **Lambda Console** ‚Üí `rag-workshop-{tu-nombre}-document-processor`
2. **Test** ‚Üí **Create test event**
3. **Event name**: `test-s3-upload`
4. **Template**: Amazon S3 Put
5. **Modificar el JSON**:
   ```json
   {
     "Records": [
       {
         "s3": {
           "bucket": {
             "name": "rag-workshop-{tu-nombre}-docs-{account-id}"
           },
           "object": {
             "key": "company_policy.txt"
           }
         }
       }
     ]
   }
   ```
6. **Save** ‚Üí **Test**
7. **Ver logs** en la respuesta:
   - ‚úÖ "Procesando documento: company_policy.txt"
   - ‚úÖ "Creados X chunks, generando embeddings..."
   - ‚úÖ "Guardados X chunks para documento company_policy"

### **3.4 Verificar Datos en DynamoDB**
1. **DynamoDB Console** ‚Üí Tu tabla `rag-workshop-{tu-nombre}-vectors`
2. **Explore table items**
3. **Scan** ‚Üí **Run**
4. **Verificar items creados**:
   - `document_id`: "company_policy"
   - `chunk_id`: "chunk_0001", "chunk_0002", etc.
   - `content`: Texto del documento
   - `embedding`: Array de n√∫meros (vectores)
   - `chunk_index`: 0, 1, 2, etc.

### **3.5 Probar Query Handler**
1. **Lambda Console** ‚Üí `rag-workshop-{tu-nombre}-query-handler`
2. **Test** ‚Üí **Create test event**
3. **Event name**: `test-query`
4. **Template**: API Gateway AWS Proxy
5. **Modificar el JSON**:
   ```json
   {
     "body": "{\"query\": \"¬øCu√°ntos d√≠as de vacaciones tengo?\"}",
     "headers": {
       "Content-Type": "application/json"
     }
   }
   ```
6. **Save** ‚Üí **Test**
7. **Ver respuesta**:
   ```json
   {
     "statusCode": 200,
     "headers": {
       "Content-Type": "application/json",
       "Access-Control-Allow-Origin": "*"
     },
     "body": "{\"query\":\"¬øCu√°ntos d√≠as de vacaciones tengo?\",\"response\":\"Seg√∫n el documento...\",\"sources\":3}"
   }
   ```

### **3.6 Analizar Logs de CloudWatch**
1. **Lambda Console** ‚Üí **Monitor** ‚Üí **View CloudWatch logs**
2. **Click** en el log stream m√°s reciente
3. **Buscar l√≠neas importantes**:
   - "Embedding generado para consulta, dimensi√≥n: 1536"
   - "Encontrados X chunks en la base de datos"
   - "Top 3 similitudes: [0.85, 0.72, 0.68]"
   - "Contexto construido con 3 chunks"

---

## üåê **PASO 4: DESPLEGAR API GATEWAY (OPCIONAL)**

### **4.1 Desplegar API Gateway**
1. **AWS Console** ‚Üí CloudFormation ‚Üí **Create stack**
2. **Upload template**: Seleccionar `api-gateway-only.yaml`
3. **Stack name**: `rag-workshop-api-{tu-nombre}`
4. **Par√°metros**:
   - **WorkshopName**: `rag-workshop` (dejar por defecto)
   - **StudentName**: `{tu-nombre}` (MISMO que usaste antes)
   - **BaseStackName**: `rag-workshop-base-{tu-nombre}` (nombre de tu stack anterior)
5. **Deploy** y esperar **CREATE_COMPLETE** (2-3 minutos)

**üí° ¬øPor qu√© estos par√°metros?**
- **StudentName**: Debe coincidir exactamente con el stack base para encontrar tus Lambda functions
- **BaseStackName**: Para referencia (informativo)
- El template construye autom√°ticamente los nombres de recursos existentes

### **4.2 Obtener URL del API Gateway**
1. **CloudFormation** ‚Üí Tu stack ‚Üí **Outputs**
2. **Copiar** el valor de `QueryEndpoint`:
   ```
   https://abc123def.execute-api.us-east-1.amazonaws.com/prod/query
   ```
3. **Anotar** esta URL para Postman

### **4.3 Probar con Postman**
1. **Abrir Postman** (o descargar desde postman.com)
2. **New Request** ‚Üí **POST**
3. **URL**: Pegar tu `QueryEndpoint`
4. **Headers**:
   ```
   Content-Type: application/json
   ```
5. **Body** ‚Üí **raw** ‚Üí **JSON**:
   ```json
   {
     "query": "¬øCu√°ntos d√≠as de vacaciones tengo?"
   }
   ```
6. **Send** ‚Üí Ver respuesta JSON:
   ```json
   {
     "query": "¬øCu√°ntos d√≠as de vacaciones tengo?",
     "response": "Seg√∫n el documento, los empleados tienen derecho a 15 d√≠as h√°biles de vacaciones anuales...",
     "sources": 2
   }
   ```

### **4.4 Probar Diferentes Consultas**
**Cambiar el body en Postman:**
```json
{"query": "¬øPuedo trabajar desde casa?"}
{"query": "¬øQu√© beneficios m√©dicos hay?"}
{"query": "¬øCu√°l es el presupuesto para capacitaci√≥n?"}
{"query": "¬øCu√°l es el horario de trabajo?"}
```

### **4.5 Verificar Logs en CloudWatch**
1. **Lambda Console** ‚Üí `query-handler` ‚Üí **Monitor**
2. **View CloudWatch logs** ‚Üí Ver logs en tiempo real
3. **Observar**:
   - Embedding generado para consulta
   - Chunks encontrados en DynamoDB
   - Similitudes calculadas
   - Respuesta generada por Claude

---

## üñ•Ô∏è **PASO 5: CONECTAR FRONTEND CON API REAL**

### **5.1 Obtener URL del API Gateway**
1. **CloudFormation Console** ‚Üí Tu stack `rag-workshop-api-{tu-nombre}`
2. **Outputs** tab ‚Üí **Copiar** el valor de `QueryEndpoint`
3. **Ejemplo**: `https://abc123def.execute-api.us-east-1.amazonaws.com/prod/query`
4. **Anotar** esta URL completa

### **5.2 Actualizar Configuraci√≥n del Frontend**
1. **Abrir** `frontend/app.js` con cualquier editor de texto
2. **Buscar l√≠nea 3** que dice:
   ```javascript
   QUERY_ENDPOINT: 'https://abc123.execute-api.us-east-1.amazonaws.com/prod/query',
   ```
3. **Reemplazar** con tu URL real:
   ```javascript
   QUERY_ENDPOINT: 'https://TU-URL-COPIADA-AQUI',
   ```
4. **Guardar** el archivo (Ctrl+S)

**üí° Ejemplo completo:**
```javascript
// Antes
QUERY_ENDPOINT: 'https://abc123.execute-api.us-east-1.amazonaws.com/prod/query',

// Despu√©s (con tu URL real)
QUERY_ENDPOINT: 'https://xyz789def.execute-api.us-east-1.amazonaws.com/prod/query',
```

### **5.3 Probar Frontend con Backend Real**
1. **Abrir** `frontend/index.html` en navegador (doble click)
2. **Subir** `test-documents/company_policy.txt` (arrastrar y soltar)
3. **Esperar** mensaje: "Documento procesado exitosamente"
4. **Hacer preguntas**:
   - "¬øCu√°ntos d√≠as de vacaciones tengo?"
   - "¬øPuedo trabajar desde casa?"
   - "¬øQu√© beneficios m√©dicos hay?"
   - "¬øCu√°l es el horario de trabajo?"
   - "¬øHay presupuesto para capacitaci√≥n?"

**üö® Si no funciona:**
- **Verificar** que guardaste `app.js` despu√©s de cambiar la URL
- **Refrescar** la p√°gina (F5)
- **Abrir Developer Tools** (F12) ‚Üí Console ‚Üí Ver errores
- **Probar** la URL en Postman primero para confirmar que funciona

### **5.4 Comparar Respuestas**
- **Simulaci√≥n vs Real**: Notar diferencias en las respuestas
- **Contexto espec√≠fico**: Las respuestas reales citan el documento exacto
- **Inteligencia**: Claude genera respuestas m√°s naturales y precisas

### **5.5 Verificar Flujo Completo**
1. **Frontend** ‚Üí Env√≠a query al API Gateway
2. **API Gateway** ‚Üí Invoca Lambda query-handler
3. **Lambda** ‚Üí Busca vectores en DynamoDB
4. **Lambda** ‚Üí Genera embedding con Titan
5. **Lambda** ‚Üí Calcula similitud coseno
6. **Lambda** ‚Üí Genera respuesta con Claude
7. **Frontend** ‚Üí Muestra respuesta al usuario

---

## üéâ **¬°FELICITACIONES! SISTEMA RAG COMPLETO**

### **‚úÖ Lo que has logrado:**
- ‚úÖ **Infraestructura serverless** con CloudFormation
- ‚úÖ **Procesamiento de documentos** con embeddings
- ‚úÖ **Base de datos vectorial** en DynamoDB
- ‚úÖ **B√∫squeda sem√°ntica** con similitud coseno
- ‚úÖ **Generaci√≥n de respuestas** con Claude 3
- ‚úÖ **API REST** con API Gateway
- ‚úÖ **Frontend interactivo** conectado
- ‚úÖ **Sistema RAG end-to-end** funcional

### **üöÄ Pr√≥ximos pasos (opcional):**
- Subir m√°s documentos PDF/TXT
- Experimentar con diferentes tipos de preguntas
- Analizar logs de CloudWatch para entender el flujo
- Modificar par√°metros como chunk_size o top_k
- Explorar otros modelos de Bedrock

### **üìö Conceptos aprendidos:**
- **RAG (Retrieval Augmented Generation)**
- **Embeddings y b√∫squeda vectorial**
- **Arquitecturas serverless**
- **Integraci√≥n de servicios AWS**
- **APIs REST y CORS**
- **Procesamiento de lenguaje natural**os empleados tienen derecho a 15 d√≠as h√°biles de vacaciones anuales...",
     "sources": 3
   }
   ```

### **4.4 Probar Diferentes Consultas**
**Cambiar el body en Postman:**
```json
{"query": "¬øPuedo trabajar desde casa?"}
{"query": "¬øQu√© beneficios m√©dicos hay?"}
{"query": "¬øCu√°l es el presupuesto para capacitaci√≥n?"}
{"query": "¬øCu√°l es el horario de trabajo?"}
```

### **4.5 Verificar Logs en CloudWatch**
1. **Lambda Console** ‚Üí `query-handler` ‚Üí **Monitor**
2. **View CloudWatch logs** ‚Üí Ver logs en tiempo real
3. **Observar**:
   - Embedding generado para consulta
   - Chunks encontrados en DynamoDB
   - Similitudes calculadas
   - Respuesta generada por Claude

---

bjeto `responses` con respuestas pre-programadas
4. **L√≠nea 145**: B√∫squeda por palabras clave
5. **L√≠nea 175**: Funci√≥n `realQuery()` para conexi√≥n real con Lambda
6. **L√≠nea 190**: Funci√≥n `sendQuery()` configurada para usar simulaci√≥n

---

## üéì **PASO 5: AN√ÅLISIS PROFUNDO DE LA ARQUITECTURA**

### **5.1 Flujo Completo de Datos**
```
üìÑ Documento (S3) 
    ‚Üì
üîÑ Document Processor Lambda
    ‚îú‚îÄ‚îÄ Extrae texto (l√≠nea 65)
    ‚îú‚îÄ‚îÄ Crea chunks (l√≠nea 75)
    ‚îú‚îÄ‚îÄ Genera embeddings con Titan (l√≠nea 95)
    ‚îî‚îÄ‚îÄ Guarda en DynamoDB (l√≠nea 115)
    ‚Üì
üóÑÔ∏è DynamoDB (vectores + texto)
    ‚Üì
‚ùì Query del usuario
    ‚Üì
üîç Query Handler Lambda
    ‚îú‚îÄ‚îÄ Genera embedding de query (l√≠nea 65)
    ‚îú‚îÄ‚îÄ Busca similitud coseno (l√≠nea 78)
    ‚îú‚îÄ‚îÄ Selecciona top 3 chunks (l√≠nea 105)
    ‚îî‚îÄ‚îÄ Genera respuesta con Claude (l√≠nea 155)
    ‚Üì
üí¨ Respuesta contextualizada
```

### **5.2 Inspecci√≥n de Embeddings**
1. **DynamoDB Console** ‚Üí Tu tabla ‚Üí **Items**
2. **Click** en cualquier item
3. **Ver campo `embedding`**:
   - Array de 1536 n√∫meros decimales
   - Cada n√∫mero representa una dimensi√≥n sem√°ntica
   - Generado por Amazon Titan Embeddings

### **5.3 Matem√°ticas de Similitud Coseno**
1. **Abrir** `lambda/query_handler/lambda_function.py`
2. **L√≠nea 78-95**: Funci√≥n `cosine_similarity()`
3. **Entender el c√°lculo**:
   ```python
   # Producto punto de vectores
   dot_product = sum(a * b for a, b in zip(vec1, vec2_float))
   
   # Normas de los vectores
   norm1 = math.sqrt(sum(a * a for a in vec1))
   norm2 = math.sqrt(sum(b * b for b in vec2_float))
   
   # Similitud coseno (0 = no similar, 1 = id√©ntico)
   return dot_product / (norm1 * norm2)
   ```

### **5.4 Configuraci√≥n de Bedrock en el C√≥digo**
**Document Processor:**
- **L√≠nea 8**: `bedrock_client = boto3.client('bedrock-runtime', region_name='us-east-1')`
- **L√≠nea 95**: `modelId="amazon.titan-embed-text-v1"` (Embeddings)
- **L√≠nea 89-105**: Funci√≥n completa de embeddings

**Query Handler:**
- **L√≠nea 8**: `bedrock_client = boto3.client('bedrock-runtime', region_name='us-east-1')`
- **L√≠nea 65**: `modelId="amazon.titan-embed-text-v1"` (Query embeddings)
- **L√≠nea 155**: `modelId="anthropic.claude-3-sonnet-20240229-v1:0"` (Generaci√≥n)
- **L√≠nea 130-175**: Funci√≥n completa RAG con Claude

### **5.5 Prompt Engineering**
1. **L√≠nea 135-150**: Prompt para Claude
2. **Elementos clave**:
   - Contexto extra√≠do de chunks relevantes
   - Instrucciones espec√≠ficas de comportamiento
   - Limitaci√≥n a informaci√≥n del contexto
   - Formato de respuesta estructurado

### **5.6 Manejo de Errores y Tipos de Datos**
1. **DynamoDB Decimal Conversion** (l√≠nea 115):
   ```python
   embedding_decimal = [Decimal(str(float_val)) for float_val in embedding]
   ```
2. **Error Handling** en cada funci√≥n
3. **CORS Headers** para frontend (l√≠nea 40-44)
4. **Logging** detallado para debugging

---

## üîç **VERIFICACIONES IMPORTANTES**

### **Verificaciones Detalladas:**
- [ ] **S3**: Bucket creado y documento subido
- [ ] **DynamoDB**: Tabla con items de chunks y embeddings
- [ ] **Lambda Document Processor**: C√≥digo actualizado y probado
- [ ] **Lambda Query Handler**: C√≥digo actualizado y probado
- [ ] **Bedrock**: Modelos habilitados (Titan + Claude)
- [ ] **CloudWatch**: Logs mostrando procesamiento exitoso
- [ ] **Frontend**: Demo funcionando con respuestas inteligentes
- [ ] **Arquitectura**: Flujo de datos entendido completamente

### **Si Hay Errores:**
1. **Consultar** `TROUBLESHOOTING_GUIDE.md`
2. **Verificar logs** en CloudWatch
3. **Revisar nombres** de recursos
4. **Confirmar regi√≥n** us-east-1

---

## üìä **M√âTRICAS DE √âXITO**

Al finalizar deber√≠as tener:
- ‚úÖ **Infraestructura AWS**: S3, DynamoDB, Lambda, IAM configurados
- ‚úÖ **Bedrock habilitado**: Titan Embeddings + Claude 3 Sonnet
- ‚úÖ **Datos procesados**: Documento chunkeado con embeddings en DynamoDB
- ‚úÖ **Lambda functions**: C√≥digo real funcionando y probado
- ‚úÖ **Demo interactivo**: Frontend con simulaci√≥n RAG inteligente
- ‚úÖ **Conocimiento profundo**: Arquitectura, c√≥digo, y conceptos RAG
- ‚úÖ **Experiencia pr√°ctica**: Navegaci√≥n completa de servicios AWS

---

## üéì **PR√ìXIMOS PASOS**

### **Mejoras Opcionales:**
1. **Soporte PDF**: Agregar PyPDF2 via Lambda Layers
2. **Chunking inteligente**: Mejorar algoritmo de segmentaci√≥n
3. **UI mejorada**: Agregar indicadores de carga
4. **M√©tricas**: CloudWatch dashboards
5. **Seguridad**: API Keys, autenticaci√≥n

### **Producci√≥n:**
1. **Monitoreo**: CloudWatch alarms
2. **Escalabilidad**: DynamoDB on-demand
3. **Costos**: Bedrock usage monitoring
4. **Backup**: Point-in-time recovery

---

## üöÄ **SECCI√ìN AVANZADA (OPCIONAL)**

### **Para Implementaci√≥n Real en AWS:**

**Opci√≥n A: Function URL (M√°s R√°pido)**
1. **Lambda Console** ‚Üí `query-handler` ‚Üí **Configuration** ‚Üí **Function URL**
2. **Create function URL** ‚Üí **Auth**: NONE ‚Üí **CORS**: Enable
3. **Copiar URL** ‚Üí Actualizar `app.js` ‚Üí Cambiar a `realQuery()`

**Opci√≥n B: API Gateway (Completo)**
1. **Usar** `api-gateway.yaml` template
2. **Seguir** pasos originales de CloudFormation
3. **Conectar** frontend con endpoint real

### **Habilitaci√≥n de Bedrock:**
1. **Bedrock Console** ‚Üí **Model access**
2. **Enable** Claude 3 Sonnet y Titan Embeddings
3. **Esperar** aprobaci√≥n (puede tomar minutos)

---

**¬°Felicidades! Has completado el workshop RAG con AWS** üéâ

**üéØ Logros:**
- ‚úÖ Demo RAG funcional
- ‚úÖ Arquitectura serverless completa
- ‚úÖ C√≥digo production-ready
- ‚úÖ Conceptos de IA aplicados